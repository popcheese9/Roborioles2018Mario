// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "DriveBase.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Drive.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveBase::DriveBase() : frc::Subsystem("DriveBase") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor1 = RobotMap::driveBaseLeftMotor1;
    rightMotor1 = RobotMap::driveBaseRightMotor1;
    diffDrive = RobotMap::driveBaseDiffDrive;
    leftMotor2 = RobotMap::driveBaseLeftMotor2;
    rightMotor2 = RobotMap::driveBaseRightMotor2;
    compressor = RobotMap::driveBaseCompressor;
    shiftController = RobotMap::driveBaseShiftController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    //invert motor
    //leftMotor1->SetInverted(true);
    //leftMotor2->SetInverted(true);

    //set left2 follow left1
    leftMotor2->Set(ControlMode::Follower,1);

    //set right2 follow right1
    rightMotor2->Set(ControlMode::Follower,3);
}

void DriveBase::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveBase::Periodic() {
    // Put code here to be run every loop

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveBase::DriveWithJoystick()
{
	diffDrive->ArcadeDrive(Robot::oi->getDriveStick()->GetY(), Robot::oi->getDriveStick()->GetX());

	double currentAmps = leftMotor2->GetOutputCurrent();
	double outputV = leftMotor2->GetMotorOutputVoltage();
	double busV = leftMotor2->GetBusVoltage();
	double outputPerc = leftMotor2->GetMotorOutputPercent();
	int quadPos = leftMotor2->GetSensorCollection().GetQuadraturePosition();
	int quadVel = leftMotor2->GetSensorCollection().GetQuadratureVelocity();

	int quadPosR = rightMotor2->GetSensorCollection().GetQuadraturePosition();
	int quadVelR = rightMotor2->GetSensorCollection().GetQuadratureVelocity();

	int quadVelRrpm = ((quadVelR*10)/4096)*60;

	frc::SmartDashboard::PutNumber("Amps",currentAmps);
	frc::SmartDashboard::PutNumber("OutputV",outputV);
	frc::SmartDashboard::PutNumber("BusV",busV);
	frc::SmartDashboard::PutNumber("OutputPerc",outputPerc);
	frc::SmartDashboard::PutNumber("QuadPos",quadPos);
	frc::SmartDashboard::PutNumber("QuadVel",quadVel);
	frc::SmartDashboard::PutNumber("QuadPosR",quadPosR);
	frc::SmartDashboard::PutNumber("QuadVelR",quadVelRrpm);
	frc::SmartDashboard::PutNumber("OGQuadVelR", quadVelR);

}

void DriveBase::UseShift()
{
   bool isEngaged = shiftController->Get();
   if(isEngaged){
	   shiftController->Set(false);
	   frc::SmartDashboard::PutBoolean("Shifted", false);
   }else{
	   shiftController->Set(true);
	   frc::SmartDashboard::PutBoolean("Shifted", true);
   }


}

void DriveBase::AutoShift(){
	double motorVelocity = rightMotor2->GetSensorCollection().GetQuadratureVelocity();
	bool isHigh = shiftController->Get();
	int rpm = ((motorVelocity*10)/4096)*60;
	if(isHigh == false && rpm > 1000){
		shiftController->Set(true);
	}

	if(isHigh == true && rpm < 750){
		shiftController->Set(false);
	}
}
